<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode547</title>
      <link href="/posts/3ae86d6e.html"/>
      <url>/posts/3ae86d6e.html</url>
      
        <content type="html"><![CDATA[<pre><code>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。返回矩阵中 省份 的数量来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/number-of-provinces著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><p>这个题的思路很简单啊，就是求一个图中的联通分量的数目呀。直接用深度遍历的方法就行了呀。首先要有一个visit的数组统一设置成0，访问到了就设置成1，从任何一个点开始做深度遍历，把深度遍历放大一个更大的循环中，进而找出联通分量的数目。至于深度遍历，肯定是直接用递归来实现。访问一个点后，对其他临街的点继续执行深度遍历，直到所有都被访问为止。</p><pre class="line-numbers language-c++"><code class="language-c++">#include<iostream>#include<vector>using namespace std;class Solution {public:    void dfs(vector<vector<int>>& isConnected,vector<int>&vist,int k,int len)    {        vist[k] = 1;        for (int i = 0; i < len; i++)        {            if (isConnected[k][i] && !vist[i])            {                dfs(isConnected, vist, i,len);            }        }    }    int findCircleNum(vector<vector<int>>& isConnected) {        int len = isConnected.size();        vector<int>vist(len);        int cout = 0;        for (int i = 0; i < len; i++)        {            if (vist[i] == 0)            {                cout++;            }            dfs(isConnected,vist,i,len);        }        return cout;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 不周山 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mainwindow</title>
      <link href="/posts/a280a607.html"/>
      <url>/posts/a280a607.html</url>
      
        <content type="html"><![CDATA[<p>mainwindow来建立大致的软件模型框架</p><pre class="line-numbers language-c++"><code class="language-c++">#include "mainwindow.h"#include <QMenuBar>#include <QToolBar>#include <QDebug>#include <QPushButton>#include <QStatusBar>#include <QLabel>#include <QDockWidget>#include <QTextEdit>MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent){    //重置窗口大小    resize(600,400);    //菜单栏  只能最多有一个    //菜单栏创建    QMenuBar * bar = menuBar();    //将菜单栏放入到窗口中    setMenuBar(bar);    //创建菜单，这两个就是左上角的文件和编辑啊    QMenu * fileMenu = bar->addMenu("文件");    QMenu * editMenu = bar->addMenu("编辑");    //创建菜单项    QAction * newAction = fileMenu->addAction("新建");    //添加分割线    fileMenu->addSeparator();    QAction * openAction = fileMenu->addAction("打开");    //可以看出来，菜单栏只是两个变量而已，首先是表头QMenu，其次是他的孩子，QAction变量    QAction *rewrite=editMenu->addAction("重写");    //工具栏  可以有多个    QToolBar * toolBar = new QToolBar(this);    addToolBar(Qt::RightToolBarArea,toolBar);    //后期设置 只允许 左右停靠    toolBar->setAllowedAreas( Qt::LeftToolBarArea | Qt::RightToolBarArea );    //设置浮动    toolBar->setFloatable(false);    //设置移动 (总开关)    toolBar->setMovable(true);    //工具栏中可以设置内容    toolBar->addAction("ps");    //添加分割线    toolBar->addSeparator();    toolBar->addAction("ae");    //工具栏中添加控件,也就是增加了一个按钮选项啊，是不是开发过程中这个应该是更管用的    QPushButton * btn = new QPushButton("aa" , this);    toolBar->addWidget(btn);    //状态栏 最多有一个    QStatusBar * stBar = statusBar();//状态栏的建立方法和菜单栏是一样的哈    //设置到窗口中    setStatusBar(stBar);    //放标签控件，相比与前面的QPushbutton，这个是QLable呀    QLabel * label = new QLabel("提示信息wfp",this);    stBar->addWidget(label);    //QLabel * label2 = new QLabel("右侧提示信息",this);    //stBar->addPermanentWidget(label2);    //铆接部件 （浮动窗口） 可以有多个    QDockWidget * dockWidget = new QDockWidget("浮动",this);    addDockWidget(Qt::BottomDockWidgetArea,dockWidget);    //设置后期停靠区域，只允许上下    dockWidget->setAllowedAreas( Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea );    //设置中心部件 只能一个    QTextEdit * edit = new QTextEdit(this);    setCentralWidget(edit);}MainWindow::~MainWindow(){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 不周山 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt信号和槽机制</title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<p>继续前天的qt学习吧，先来看看几个文件：</p><pre class="line-numbers language-c++"><code class="language-c++">widget.h#ifndef WIDGET_H#define WIDGET_H#include <QWidget>#include "teacher.h"#include "student.h"namespace Ui {class Widget;}class Widget : public QWidget{    Q_OBJECTpublic:    explicit Widget(QWidget *parent = 0);    ~Widget();private:    Ui::Widget *ui;    Teacher * zt;    Student * st;    void classIsOver();};#endif // WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">widget.cpp#include "widget.h"#include "ui_widget.h"#include <QPushButton>#include <QDebug>//Teacher 类  老师类//Student 类  学生类//下课后 ，老师会触发一个信号，饿了 ，学生响应信号，请客吃饭void func(){    qDebug() <<"aaa";}Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget){    ui->setupUi(this);    //创建一个老师对象    this->zt = new Teacher(this);    //创建一个学生对象    this->st = new Student(this);//    //老师饿了 学生请客的连接//    connect(zt,&Teacher::hungry,st,&Student::treat);//    //调用下课函数//    classIsOver();    //连接带参数的 信号和槽    //指针 -> 地址    // 函数指针 -> 函数地址    void(Teacher:: *teacherSignal)(QString  ) = &Teacher::hungry;    void(Student:: *studentSlot)(QString  )  = &Student::treat;    connect(zt,teacherSignal,st,studentSlot);        //从这里看的话，这是定义了一个参数为QString的函数的指针，这样的方式就区分出来了，其实这个写法我以前是没有见过的   // classIsOver();    //点击一个 下课的按钮 ，再触发下课    QPushButton * btn = new QPushButton("下课",this);    //重置窗口大小    this->resize(600,400);    //点击按钮 触发下课通过按钮来触发class over的函数    //connect(btn,&QPushButton::clicked,this,&Widget::classIsOver);    //无参信号和槽连接    void(Teacher:: *teacherSignal2)(void) = &Teacher::hungry;    void(Student:: *studentSlot2)(void)  = &Student::treat;    //connect(zt,teacherSignal2,st,studentSlot2);    //信号连接信号    connect(btn,&QPushButton::clicked, zt, teacherSignal2);    //断开信号    //disconnect(zt,teacherSignal2,st,studentSlot2);    //拓展    //1、信号是可以连接信号    //2、一个信号可以连接多个槽函数    //3、多个信号 可以连接 同一个槽函数    //4、信号和槽函数的参数 必须类型一一对应    //5、信号和槽的参数个数  是不是要一致？信号的参数个数 可以多余槽函数的参数个数    //Qt4版本以前的信号和槽连接方式    //利用Qt4信号槽 连接无参版本    //Qt4版本 底层SIGNAL("hungry")  SLOT( "treat")    connect(zt,SIGNAL(hungry()) , st , SLOT(treat()));    //Qt4版本优点：参数直观，缺点 ：类型不做检测    //Qt5以上  支持 Qt4的版本写法，反之不支持//    QPushButton * btn2 = new QPushButton;//    [btn](){//        btn->setText("aaaa");//        btn2->setText("bbb"); //btn2看不到//    }();    // mutable关键字 用于修饰值传递的变量，修改的是拷贝，而不是本体//    QPushButton * myBtn = new QPushButton (this);//    QPushButton * myBtn2 = new QPushButton (this);//    myBtn2->move(100,100);//    int m = 10;//    connect(myBtn,&QPushButton::clicked,this,[m] ()mutable { m = 100 + 10; qDebug() << m; });//    connect(myBtn2,&QPushButton::clicked,this,[=] ()  { qDebug() << m; });//    qDebug() << m;//    int ret = []()->int{return 1000;}();//    qDebug() << "ret = " << ret ;    //利用lambda表达式 实现点击按钮 关闭窗口    QPushButton * btn2 = new QPushButton ;    btn2->setText("关闭");    btn2->move(100,0);    btn2->setParent(this);        //下面的这一步lambda表达式[=]表示能够引用范围内的可见的局部变量，其中本来的槽函数是可以省略的。        connect(btn2,&QPushButton::clicked, [=](){//我感觉这样省了去写一个classover的这个函数，直接用这种方法来直接发送信号多好呀，哈哈哈//        this->close();//        emit zt->hungry("宫保鸡丁");        btn2->setText("aaaa");    });    //lambda表达式 最常用  [=](){}}void Widget::classIsOver(){    //下课函数，调用后 触发老师饿了的信号    //emit zt->hungry();    emit zt->hungry("宫保鸡丁");//因为classover是属于widget类中的函数，所以定义的时候是单独拿出来定义的啊，这里是满足了槽函数和信号函数的参数变量是一样的，所以才能够传递的原理啊}Widget::~Widget(){    delete ui;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看一下写的两个类函数：student和teacher：</p><pre class="line-numbers language-c++"><code class="language-c++">student.h#ifndef STUDENT_H#define STUDENT_H#include <QObject>class Student : public QObject{    Q_OBJECTpublic:    explicit Student(QObject *parent = 0);signals:public slots:    //早期Qt版本 必须要写到public slots，高级版本可以写到 public或者全局下    //返回值 void ，需要声明，也需要实现    //可以有参数，可以发生重载    void  treat();    void  treat(QString foodName);};#endif // STUDENT_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">student.cpp#include "student.h"#include <QDebug>Student::Student(QObject *parent) : QObject(parent){}void Student::treat(){    qDebug()<< "请老师吃饭";}void Student::treat(QString foodName){    //QString -> char * 先转成 QByteArray  ( .toUtf8() ) 再转char * ( .data() )    qDebug() << "请老师吃饭，老师要吃:" << foodName.toUtf8().data() ;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">teacher.h#ifndef TEACHER_H#define TEACHER_H#include <QObject>class Teacher : public QObject{    Q_OBJECTpublic:    explicit Teacher(QObject *parent = 0);signals:    //自定义信号  写到signals下    //返回值是void ，只需要声明，不需要实现    //可以有参数，可以重载    void hungry();    void hungry(QString foodName);public slots:};#endif // TEACHER_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>teacher.cpp#include "teacher.h"Teacher::Teacher(QObject *parent) : QObject(parent){}//其实从这里就可以发现，我只需要声明一下这个函数，这个函数不需要做任何事情</code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="E:%5Ctt%5Csource%5C_posts%5C2021-1-6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5CQt%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%20.png" alt="Qt信号和槽 "></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 不周山 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode399除法求值</title>
      <link href="/posts/56ddf307.html"/>
      <url>/posts/56ddf307.html</url>
      
        <content type="html"><![CDATA[<pre><code>给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。示例 1：输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]解释：条件：a / b = 2.0, b / c = 3.0问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]示例 2：输入：equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]输出：[3.75000,0.40000,5.00000,0.20000]示例 3：输入：equations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]]输出：[0.50000,2.00000,-1.00000,-1.00000]来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/evaluate-division著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><p>这个题我没有做出来，看了答案，思路：</p><ol><li>利用map表将string类型与图的索引结合一起，为创建图做准备</li><li>建立图，这里建立的是vector&lt;vector&lt;pair&lt;&gt;&gt;类型的图，这里利用find和for in，打破了以前必须利用i的禁锢</li><li>利用广度遍历</li></ol><pre class="line-numbers language-c++"><code class="language-c++">#include<iostream>#include<unordered_map>#include<vector>#include<string>#include<queue>using namespace std;class Solution {public:    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {        int nvars = 0;        unordered_map<string, int> variables;        int n = equations.size();        for (int i = 0; i < n; i++) {            if (variables.find(equations[i][0]) == variables.end()) {                variables[equations[i][0]] = nvars++;            }            if (variables.find(equations[i][1]) == variables.end()) {                variables[equations[i][1]] = nvars++;            }        }//这一步的目的是把string串与图的下标对应起来        // 对于每个点，存储其直接连接到的所有点及对应的权值        vector<vector<pair<int, double>>> edges(nvars);        //两个vector创建出一个图，pair写出权值，很厉害的        for (int i = 0; i < n; i++) {            int va = variables[equations[i][0]], vb = variables[equations[i][1]];            edges[va].push_back(make_pair(vb, values[i]));            edges[vb].push_back(make_pair(va, 1.0 / values[i]));        }        vector<double> ret;        for (const auto& q : queries) {            double result = -1.0;            if (variables.find(q[0]) != variables.end() && variables.find(q[1]) != variables.end()) {                int ia = variables[q[0]], ib = variables[q[1]];//人家这个散列表用的真的狠                if (ia == ib) {                    result = 1.0;                }                else {//开始遍历图了呀，这里用广度遍历，之所以不选择prime是因为没有必要求到每一个点的                    queue<int> points;                    points.push(ia);                    vector<double> ratios(nvars, -1.0);                    ratios[ia] = 1.0;                    while (!points.empty() && ratios[ib] < 0) {                        int x = points.front();                        points.pop();                        for (const auto tmp : edges[x]) {                            if (ratios[tmp.first] < 0) {                                ratios[tmp.first] = ratios[x] * tmp.second;                                points.push(tmp.first);                            }                        }                    }                    result = ratios[ib];                }            }            ret.push_back(result);        }        return ret;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 不周山 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我有个骑行的计划</title>
      <link href="/posts/ec1b1c50.html"/>
      <url>/posts/ec1b1c50.html</url>
      
        <content type="html"><![CDATA[<p>本来在去年的时候，我曾经幻想过，如果我能成功，我要从武汉出发，来一场骑行，10天的时间，我就可以去深圳了，可如今，考完研，对完答案，我好想哭。。。。我明明复习的非常不错了，可是，我在考场上的时候却像是一个傻子，我什么都做不到，我真的是一个笨蛋啊。本来答应了那么多人，我会去看他们，我又一次的把那些话一个人咽进了自己的肚子里。</p><p>多想，多想有一天这些事能够实现，也算是为我的青春留下一个交代，多想啊。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 好望角 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1月4日学习笔记</title>
      <link href="/posts/cec82287.html"/>
      <url>/posts/cec82287.html</url>
      
        <content type="html"><![CDATA[<h1 id="1月4号，考完研后的一周"><a href="#1月4号，考完研后的一周" class="headerlink" title="1月4号，考完研后的一周"></a>1月4号，考完研后的一周</h1><p>​      考完研后，调整了一下状态，也在思考原因，休整了几天之后，决定鼓起勇气面对后面的事情，做一个好一点的计划，于是2021年1月4号开始了正式的学习了。今天看的git的应用与qt的界面开发的部分，其实我也在思考我学习过程中的缺点，我可能真的是仅仅喜欢新的东西，而不懂得及时的回顾，每当回顾的时候，我就喜欢拖延，最后的结果就是学完了也就忘了，这可能就是我的缺点吧。</p><hr><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>GIT相当于一个做版本控制的软件，挺高级的。今天学习了最基础的命令。</p><ol><li>在需要管理的文件夹内打开git bash，而后初始化操作：git init </li><li>查看文件夹中的文件状态:git status ,新建立的和修改过的都是红色的，其实这里是深究了还挺复杂的，以后讨论。</li><li>添加文件到管理（把红色变成绿色）git add .</li><li>生成需要的版本：git commit -m’版本名’</li><li>查看版本记录：git log</li></ol><p>上面就是git最基本的操作了，结合实际工作考虑特殊情况。</p><p>我在之前s的版本添加代码，写成一个新的版本，但是，如果我想退回原来的版本如何做？<strong>回滚</strong></p><ul><li><p>回滚到之前的版本</p><pre class="line-numbers language-c++"><code class="language-c++">git loggit reset --hard 版本号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>回滚到之后的版本</p><pre><code>git refloggit reset --hard 版本号</code></pre></li></ul><p>其实git最厉害的一个东西在于分支，下面结合案例说一下分支，为什么引用分支呢？看如下场景，我在写新的模块，但是我之前的模块出了bug，想要修复，这时我如果退回去，那么我新写的就没有了。所以，bug和dev其实都是用的分支，分支完了再进行合并。至于那个合并之后把之前的删掉是怎么回事？？</p><ol><li><p>创造分支：git branch name</p></li><li><p>切换分支：git checkout name</p></li><li><p>git merge name(这里要注意一件事，所有的合并，其实本体都是master的)（合并后的内容是可以把之前的分支给删除掉的，是因为合并的版本已经有了分支的内容吧）</p></li><li><p>删除分支：git branch -d name</p><hr><h2 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h2><h3 id="WIDGET类"><a href="#WIDGET类" class="headerlink" title="WIDGET类"></a>WIDGET类</h3><p>之后看了qt最简单的一些东西，qt建立的基于widget类建立h和cpp，除此之外就是main函数了。main函数中两个变量，Qapplication和widget，其中前者唯一，我们的主要操作主要基于后者。基于widget的类添加各种各样的新类。关于新类是如何构造的，关于那个parent我是有点不太懂的。</p><p>widget中的几个函数resize，setwindowtitle，setfixedsize</p><p>QPushbutton按钮类setparent（this）：这一步其实就把按钮一块给放到widget上了；settext按钮的名字；move移动位置</p><h3 id="信号和槽机制"><a href="#信号和槽机制" class="headerlink" title="信号和槽机制"></a>信号和槽机制</h3><p>signal和spot，其中信号的函数只要声明就行了，它不需要做出任何动作，槽函数来负责具体动作。二者通过connect来连接。</p><p>系统的信号，感觉主要就是一些click点击之类的，比方说点击一个按钮，就关闭窗口这类connect</p><pre><code>connect（变量，信号，变量，槽函数）connect（btn,&amp;QPushButton::clicked,this,&amp;Mywidget::close）;//系统类的</code></pre><p>关于自定义的函数重载我还是不太懂。</p><p>connect函数要写在调用函数之前，调用函数中的发送信号的函数这样写： emit 自定义信号</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 不周山 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题830</title>
      <link href="/posts/a6f5b56e.html"/>
      <url>/posts/a6f5b56e.html</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode每日一题830"><a href="#leetcode每日一题830" class="headerlink" title="leetcode每日一题830"></a>leetcode每日一题830</h1><pre><code>在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。例如，在字符串 s = "abbxxxxzyy" 中，就含有 "a", "bb", "xxxx", "z" 和 "yy" 这样的一些分组。分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 "xxxx" 分组用区间表示为 [3,6] 。我们称所有包含大于或等于三个连续字符的分组为 较大分组 。找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/positions-of-large-groups著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。、</code></pre><p>个人的解法：单纯利用两个指针，很简单的思路。</p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;//我拿到这个题的第一个思路就是设置出两个指针，将两个坐标的差与三来比较，进而寻找出这个字符串class Solution {public:    vector&lt;vector&lt;int&gt;&gt; largeGroupPositions(string s) {        int i = 0, j = 1;        vector&lt;vector&lt;int&gt;&gt;result;        while (j&lt; s.length())        {            vector&lt;int&gt;tmp;            if (s[i] == s[j])            {                j++;            }            else             {                if (j - i &gt; 2)                {                    tmp.push_back(i);                    tmp.push_back(j-1);                    result.push_back(tmp);                }                i = j;                j++;            }        }        if (j - i &gt; 2 &amp;&amp;s[i]==s[j-1])        {            vector&lt;int&gt;tmp;            tmp.push_back(i);            tmp.push_back(j - 1);            result.push_back(tmp);        }        return result;    }};</code></pre><p>同样的思路，别人写的代码，哎，写的也比我好太多了。</p><pre><code>通过两个指针指向窗口的首端和尾端。通过尾端的不断确定相同元素，进行窗口尾端向右移动。如果尾端元素与首端元素不同，则说明达到窗口的最大值，则查看窗口内元素是否达到3，如果达到3则记录。最后将窗口首端直接移动到与尾端相同位置(有KMP记忆的思想)。当两个指针都达到末端则结束。作者：chong-xi链接：https://leetcode-cn.com/problems/positions-of-large-groups/solution/hua-dong-chuang-kou-jie-fa-han-kmpsi-xia-qgcv/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。class Solution {public:    vector&lt;vector&lt;int&gt;&gt; largeGroupPositions(string s) {        int prev = 0;        int last = 0;        vector&lt;vector&lt;int&gt;&gt; res;        while (s[last]||s[prev]){           //s[end] = '\0' 为false            if (s[prev]==s[last]) last++;            else {                if ((last-prev-1)&gt;=2){                    res.push_back({prev,last-1});                }                prev = last;            }        }        return res;    }};</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 不周山 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志随笔2020.10.17</title>
      <link href="/posts/19er124.html"/>
      <url>/posts/19er124.html</url>
      
        <content type="html"><![CDATA[<p>10月也已经过了大半了，今天其实整体感觉也还好，就是要这样一点点的进入状态，稍等，我先去烧水泡个脚。</p><p>决定先不看哔哩哔哩了，攒好一切来冲刺考研，不能被别的事情来分心呢。这一点也挺重要的。要按照每一科来复习，否则学着学者就忘了。看看IT之家，看看漫画都行，但有一点，不刷视频。浪费时间，全心全意的来复习。</p><p>今天想起一些失去了的朋友，自己做了一段rap的词，打算把这个做成歌，叫什么呢？</p><p>就叫做，我的朋友吧。嗯，也不错，希望能做出优秀的作品吧。</p><p>争分多秒的过程也得让自己平和下来，不能操之过急。明天有项目要搞，公司的活，怪烦的，不过也得做。保持效率，保持效率。从新启动之前的学习方法，应该更适合我。明天加油！@wfp</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 燕子集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志随笔2020.10.14</title>
      <link href="/posts/19d2124.html"/>
      <url>/posts/19d2124.html</url>
      
        <content type="html"><![CDATA[<p>日子一天天的过，学会成熟，学会去说谎话，学着不再跟人分享喜悦，学会不被道德绑架。</p><p>这几天有点隐隐的健身坚持不住的感觉，或许是到了饮食的瓶颈期了吧，到拼多多上一会在买一些营养品补一补吧。</p><p>想起自己新改的那个签名，一走，我不送，你来，我雨里相迎。</p><p>可能别人看来我就是个冷酷无情的人吧，我不在乎失去身边的任何人，因为我明白，他们都只陪我走一段路程的人，过段时间，他们与我，也就什么都不是了，这就是我的价值观，我也在用我的价值观去审视着身边的人，也许，人与人之间最好的关系，真的只出现在小时候吧，我给一点吃的，你就是我的朋友，在我需要帮助你挺身而出，你就是我的兄弟，现在，真的呵呵，再好的关系都会一触即破。有多少兄弟都是最后老死不相往来，呵。我真的不在看重这些东西了，你有才能，有本事，谁都来巴结你，哎，就是这么残酷，也不想再说了。</p><p>还是打算明天开始分类复习，一天看一门，感觉时间走的飞快，没有留下什么，明天，继续努力吧，早起背英语，不要在乎现实，不要在乎别人怎么看你，不要去在乎成功还是失败，记住，你就是自己的英雄，你的喜怒哀乐也是自己的，他人，休得再占取分毫。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 燕子集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志随笔2020.10.13</title>
      <link href="/posts/19d2334.html"/>
      <url>/posts/19d2334.html</url>
      
        <content type="html"><![CDATA[<p>距离考研还有74天，用了两天的时间，终于将政治的题全部整理完毕了，感觉自己也是挺神速的。不过还是觉得一个人复习的效率不是很高。打算明天利用好番茄钟，试一下，我一天能学几个25分钟，从而建立一套真正意义上的有效率的学习方法。</p><p>今天健身房来了一个小哥，人也挺帅的，我邀请他一起练，我说平时就我一个人练，那几个妹子只打桌球，我练的都想放弃了。他看看我，说，大哥，你练的挺好，要指导我啊。我：？？哎，我这种没入门的人，在别人的眼里估计也还挺厉害的，哈哈。</p><p>今天看了看网易云音乐人收入，收入为0，哎，只有一首自由之路的播放量还可以，那首Y还被一个女生给嘲笑了。…..这种日子到底还要多久，我什么时候才能成为说唱歌手？我发四，以后所有歌都不会唱hook，唱就打死。</p><p>我觉得咸鱼的虚拟商品真的可以开发一下，在咸鱼买了一份资料，反手又挂在自己主页，两天赚了30多。很想研究研究自动发货的脚本，用咸鱼卖虚拟商品，在虚拟版权还没有完善的时候，一定是没有问题的。</p><p>早点休息，睡觉前涂点美白精华，喝杯牛奶，明天又是精致的生活，night！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 燕子集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志随笔2020.10.12</title>
      <link href="/posts/19d2a4e7.html"/>
      <url>/posts/19d2a4e7.html</url>
      
        <content type="html"><![CDATA[<p>距离考研还有75天，我拿起了政治书，是的，真的开始复习政治了。相比之前，这次的复习速度要快上很多，今天看了一整天，估计明天再看一天，应该可以把政治一轮给拿下吧。还是应该把时间留给数学跟英语，毕竟都考了那么多次了，还是一点长进没有。</p><p>今天开始，青岛出了9个无症状感染，也是挺慌了的吧，我有点担心，如果考研的时候，也是疫情爆发的期间，该怎么办呢？恍恍惚惚，才发现，已经一年了，到了该冲刺的日子了。</p><p>还是一如既往的去健身房，跟他们偶尔聊聊天，说来惭愧，目前练的满意的，也就是胸了，还记得高中特别有意思的事情，当时体检，我看一个妹子的体检单，一脸惊讶的对她说，我去，你那么瘦，为什么胸围比我大，我记得没错的话，当时数据应该是82。她满脸通红，过了好久我才反应过来。现在想来，怪有意思的，可能，对一个有好感的人的记忆，总是很难忘记，偶然想起，心中温暖的感觉，大致就是这样吧。只是如今物是人非，想来还有点惆怅，感慨青春真好。</p><p>加油吧，75天。为了梦又瘦了十斤，为了坚持这份执心，为了赢我得再使劲，为了痛不得不放下，为了变得体的代价。你不得不理解的这份沉重。记得三年前，我站在台上，说我不怕，现实多奸诈，我要带你们去见证我所书写的荣耀。我的天啊，你当时到底打了些什么仗，除了爱你的人，其他人都觉得你太可悲。上天夺走了我的翅膀，要我经历这人间的沧桑迷茫，可我本就来自天上，必然要再回到天上，而这一路，已经没人配与我共享，在孤独中保持自信，就是这种感觉吧，晚安啊！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 燕子集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这一次，从hexo开始</title>
      <link href="/posts/eb6ebd37.html"/>
      <url>/posts/eb6ebd37.html</url>
      
        <content type="html"><![CDATA[<p>今天是十月11号凌晨两点，从10月4号开始部署自己的博客，也快有一个周了吧。我才发现，我已经有好多年不熬夜了，5号那天，我熬了一宿，猛然看窗户，已经大亮我仔细的去想，上一次熬夜是什么时候呢，我想起来了，是第一次做公众号的时候吧。</p><p>我在内心确定，我是适合做技术的，我一旦钻进去一个东西，有瘾的。这种感觉，让我不会产生疲惫感。我喜欢把东西做出来那一瞬间的成就感，我知道，这是属于我的。</p><p>matery的主题模板，陆陆续续改了一些东西，添加了相册，添加了我的网易云音乐，我把哔哩哔哩的视频也都放上去了，我觉得一个博客就像是一个人的标签，一个仓库，他代表了你一路走来，所拥有的东西，所学会的东西，看到这些东西让我觉的我的生活是有意义的。</p><p>之前学过一点前端，做了这次的博客，我觉得web的网站开发，真的可以多试一试的，有意思，我打算在以后慢慢的学习web，就利用平时休息的时间，应该也会慢慢一点一点的积累吧。</p><p>今天先到这吧，实在是太困了，我的文字就像流水账，写不动，脑袋装不了太多东西了。</p><p>我在想，我把这类文章分到什么标签。啊，我的目标是，成为终生 学习者，不断向大佬们学习！！，终生学习，是我的第二个标签。</p><p>晚安，明天要更努力，你能成为你想要成为的人！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 通天塔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020.10.1日志随笔</title>
      <link href="/posts/e3e08109.html"/>
      <url>/posts/e3e08109.html</url>
      
        <content type="html"><![CDATA[<p>又到十月一，突然发现这一年过的真的快，一转眼就结束了的那种。这大半年到底经历了什么呢？让时间过的这么快。</p><p>呵呵，我这半年总在立flag与打破flag中不断的循环与挣扎，从最开始的复试就这样，拖延加定制的任务不能够完成，然后再去不断的自责，并树立最新的flag：</p><p>每天用番茄闹钟打卡，每天用xmind记录日记，不去看斗鱼温柔的视频，不去看污污的韩漫。</p><p>我总是间接性的热血，持续的混吃等死，我似乎有时候觉得，这就是我的常态了。我如果没什么出息，也就一辈子这样了吧。</p><p>可我总要改变，因为我不想亲手毁掉当初意气风发的选择，去向这个世界证明我当初的决定都是错的，我需要拿出成绩，给我自己一个交代，我不想永远看着别人的朋友圈去难过，去一个人孤独，我不想拿着5000块钱的工资老去，我还想找一个喜欢的女朋友。</p><p>我需要沉下心来，把这几年的挫折当成财富，我需要成为一个拥有自制力，成为一个言出必行的人。让自己说的话又分量，成为一个让我自己佩服的人。千淘万漉虽辛苦，吹尽狂沙使到金。</p><p>自制力，在我没有一个很好的环境下，在闹市，我能成为成为一个拥有定力的人，那才是我最想能够做到的人吧。无数次的从明天开始，今天，我真的，不想在拥有明天这种说辞了，我想今天改变了，凤鹏，你能不能做到呢。</p><p>这决定了你到底能不能考研成功呢。我总是在意，我在意以前的朋友在我落魄的时候，还能不能想起我，呵！这种想法怎么这么幼稚呢，我在一次次的失落中，真真正正的感受到了，你的社交圈，仅仅是取决于你的实力，别再把注压到朋友的身上了，这一次，我压到自己的身上。</p><p>不要让无休止的时间，磨灭了你作为一个梦想者该有的执着，加油啊。我的朋友。不再下载哔哩哔哩看东西了，把自己的社区，集中到leetcode与csdn上吧，强迫自己去热爱梦想，不再看斗鱼了。</p><p>不再去接触那些让人玩物丧志的东西了。我只有这一次机会了吧，哈哈哈。我妈妈说我十一能转运，让我在家里好好呆着，我相信命运，我更相信我的妈妈。还记得三年前，三年前，你在北京留下的誓言嘛，我知道，那些吹过的牛逼，已经没有办法再去实现了，很遗憾，但是，我可以的，我一定可以的，去继续书写我的荣耀。 </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 燕子集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人海人山</title>
      <link href="/posts/19d2a4e6.html"/>
      <url>/posts/19d2a4e6.html</url>
      
        <content type="html"><![CDATA[<p>最近的复习状态一直不是很好，我在尝试各种方法去解决，但是收到的效果甚微。我还是忍不住的打开朋友圈去翻朋友们的动态，去看他们在过什么样的生活，去了工大的，去了交大的的，甚至是去了部队的。</p><p>我并不是羡慕他们的生活，我今年也是有点浮躁，第一年的考研经历，我是从中吸取了教训了的。那年的我更浮躁，我能够去解决的，那已经不再是什么不可战胜的洪水猛兽了。可是如今的我，不光是浮躁了，我感觉压抑的很，黑暗中扑面的孤独感，在宁静的夜的某个瞬间，让我窒息。我一直觉得我是一个独来独往的人，我喜欢一个人，我不喜欢等人，他们都太笨了，他们的格局都太低了，只有我一个人的时候，我做事的时候才不用去将就别人，那是最游刃有余的我。</p><p> 可是，真的是这样嘛？为什么现在的我这么压抑，这么难受？是身边少了小马的鼓励，少了与傲神的侃侃而谈，少了小田在身边学习时的那一份从容？少了茂运和田金来问我题的时候的我解决之后那自信的嘴角？        我好想他们啊，他们在的时候，我才觉得那是考研吧！现在的我，没处去发泄，没法去自豪，没法去认可自己。我只能一个人去默默的学习，胜败只于我一个人，分享不了喜悦，也分享不了忧伤…….     </p><p>之前听过一首歌，叫《人海人山》：“誓要铁树开花结果江水东去不复返，陪着窗外大雨倾盆迎接清晨的那种无助感。”谁不是呢？幻想着一鸣惊人的闪光点，能够照耀着数千里的暗淡夜。在一次又一次的失意焦虑暴躁失望痛心绝境中不断死去然后重生。“困在瓶颈深处的艺术家，永远前进不回头，为了采摘彼岸的一束花，用尽了一生的回眸，走出丛林的菩提树，从此只有他和岸，永远不会在迷路，度与逐流的阿罗汉” </p><p>听到这句的时候，我有些怅然若失，从此只有他和岸这句话，是不是在告诉我，要想走到路的尽头，陪伴你的只有孤独呢？</p><p>  我去看大一大二时百度云里存的照片，那时我的眼神里面，真的有星辰大海，现在暗淡了很多。我知道我必须跳出现在的这个死循环。</p><p> 在平凡的日子中去寻找自己生活中的闪光点，这也是我开始想去做歌的原因，去寻找属于自己的认同感，去尝试取悦自己吧，去认可自己的价值。</p><p>身边的同事问我为什么三战去考研，因为我不想认输啊，哪怕触底都要去反弹，不断的去修炼自己，去飞过万丈深渊，并成为一个真正的男人！ </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 燕子集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>压抑的孤独</title>
      <link href="/posts/7a46f93c.html"/>
      <url>/posts/7a46f93c.html</url>
      
        <content type="html"><![CDATA[<p>或许打败我的</p><p>不是这几年的困难而是这最后一年的孤独</p><p>这一年的自我怀疑</p><p>你命中注定的孤独</p><p>命中注定的没人喜欢你没人爱你</p><p>是啊</p><p>这一切都是命中注定</p><p>那我现在在这里还有什么意义</p><p>心气，不服气，又都有什么意义</p><p>你也看到了啊</p><p>没人喜欢我他们都在讨厌我</p><p>是啊</p><p>他们为什么都讨厌我</p><p>讨厌我的傲慢</p><p>讨厌我那着急的情商</p><p>讨厌我的嘴脸</p><p>讨厌我的一切</p><p>你以为的关系都很脆弱</p><p>没人愿意在你跌倒的时候问候</p><p>你哪怕你站起来又如何</p><p>没人关心你的</p><p>我真的已经受不了了</p><p>我已经丢了我们这个词汇了</p><p>为了不被抛弃我只能变得更加的自私</p><p>做自己的观众</p><p>去听我创作的歌曲</p><p>欣赏我的肌肉</p><p>去一笔一画我那烂透了的书法</p><p>或许我这种人</p><p>不是不配别人的喜欢</p><p>而是，</p><p>不需要吧我很难受，</p><p>但只能这样</p><p>可我仍然希望有一天</p><p>有个人愿意为了我而喝彩而那个人，</p><p>不只是我的妈妈</p><p>如果有这么一个人</p><p>哪怕别人都不喜欢我</p><p>我都不怕</p><p>因为我本来就是偏执的，</p><p>就是倔强的，</p><p>就是高傲的可是，</p><p>我受不了这份没人认可的孤独</p><p>我需要一个人来理解我内心的孤独</p><p>在每一个孤独的夜晚</p><p>我多么想哭</p><p>我睡不着脑子里的画面</p><p>总是一直闪我难过，</p><p>什么都让我难过 </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 燕子集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研路 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
